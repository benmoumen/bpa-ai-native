// Prisma Schema for BPA AI-Native
// Database: PostgreSQL
// ORM: Prisma 7.x
//
// Naming Conventions:
// - Models: PascalCase (User, Session)
// - Tables: snake_case via @@map("table_name")
// - Fields: camelCase in TypeScript
// - Columns: snake_case via @map("column_name")

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  // Note: Connection URL is configured in prisma.config.ts
  // For local development, set DATABASE_URL in .env
}

// =============================================================================
// Enums
// =============================================================================

/// ServiceStatus enum - tracks the lifecycle state of a service
enum ServiceStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

/// CostType enum - defines how cost amounts are calculated
enum CostType {
  FIXED   // Fixed amount specified directly
  FORMULA // Calculated using JSONata expression
}

/// DeterminantType enum - defines the data type of a determinant
enum DeterminantType {
  STRING  // Text-based values (TEXT, EMAIL, PHONE, TEXTAREA, SELECT, RADIO)
  NUMBER  // Numeric values
  BOOLEAN // True/false values (CHECKBOX)
  DATE    // Date values
}

/// FormType enum - defines the purpose of a form
enum FormType {
  APPLICANT // Citizen-facing data collection form
  GUIDE     // Operator/staff workflow form
}

/// RoleType - discriminator for Role polymorphism
enum RoleType {
  USER // Human decision point (operator/approver)
  BOT  // Automated processing (integrations)
}

/// RoleStatusCode - 4-Status Model (FIXED, non-negotiable)
/// These codes map to legacy BPA: PENDING=0, PASSED=1, RETURNED=2, REJECTED=3
enum RoleStatusCode {
  PENDING  // 0 - Waiting for decision
  PASSED   // 1 - Approved, moves forward
  RETURNED // 2 - Sent back for fixes (can retry)
  REJECTED // 3 - Permanently rejected (terminal)
}

// =============================================================================
// ADR Foundation Enums (ADR-002, ADR-003)
// =============================================================================

/// ProcedureType - defines the output type of a procedure (ADR-002)
enum ProcedureType {
  AUTHORIZATION  // Issues document (license, permit, certificate)
  INQUIRY        // Returns information (no document issued)
  OBLIGATION     // Collects required data (compliance, tax filing)
  NOTIFICATION   // Acknowledges receipt (no approval workflow)
}

/// TriggerType - defines who/what initiates the procedure (ADR-002)
enum TriggerType {
  USER_INITIATED  // Applicant decides to apply
  SCHEDULED       // Time-based trigger (annual renewal)
  INSTITUTION     // Government requires submission
  EVENT           // External trigger (ownership change, relocation)
}

/// ActorType - identifies who performs actions in workflow (ADR-003)
enum ActorType {
  APPLICANT  // The person/entity applying
  OPERATOR   // Government staff processing
  SYSTEM     // Automated bot processing
}

/// ElementType - categorizes application components (ADR-003, future use)
enum ElementType {
  QUALIFIER    // Questions determining other elements (was GUIDE)
  DATA         // Information collection (was APPLICANT form)
  EVIDENCE     // Document uploads
  PAYMENT      // Fee items
  DECLARATION  // Sworn statements, terms acceptance
  SUBMISSION   // Final submit action
}

/// RelationType - defines relationships between elements (ADR-003, future use)
enum RelationType {
  SHOWS       // Answer shows another element
  HIDES       // Answer hides another element
  REQUIRES    // Element requires another
  CALCULATES  // Element calculates value
  VALIDATES   // Element validates another
  ROUTES_TO   // Element routes to workflow step
}

// =============================================================================
// User & Authentication Models
// =============================================================================

/// User model - represents authenticated users from Keycloak
model User {
  id         String    @id @default(cuid())
  email      String    @unique
  name       String?
  keycloakId String    @unique @map("keycloak_id")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  sessions   Session[]
  services   Service[]

  @@map("users")
}

/// Session model - tracks active user sessions
model Session {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

// =============================================================================
// Service Models
// =============================================================================

/// Service model - represents a configurable government service
model Service {
  id          String        @id @default(cuid())
  name        String        @db.VarChar(255)
  description String?       @db.Text
  category    String?       @db.VarChar(100)
  status      ServiceStatus @default(DRAFT)
  createdBy   String        @map("created_by")
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Relations
  creator       User           @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  registrations Registration[]
  forms         Form[]
  determinants  Determinant[]
  roles         Role[]

  // Indexes for common query patterns (NFR4: service list < 1s)
  @@index([status])
  @@index([createdBy])
  @@index([createdAt])
  @@map("services")
}

// =============================================================================
// Template Models
// =============================================================================

/// ServiceTemplate model - pre-defined service templates for quick-start creation
/// Templates contain placeholder configurations that become functional as form/workflow features are added
model ServiceTemplate {
  id              String   @id @default(cuid())
  name            String   @db.VarChar(255)
  description     String?  @db.Text
  category        String   @db.VarChar(100)
  previewImageUrl String?  @map("preview_image_url") @db.VarChar(500)

  // Metadata computed from config (placeholder counts for Phase 1)
  formCount       Int      @default(0) @map("form_count")
  workflowSteps   Int      @default(0) @map("workflow_steps")

  // Template configuration stored as JSON
  // Structure: { forms: [], workflow: { steps: [] } }
  config          Json     @default("{}")

  // System fields
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@index([category])
  @@index([isActive])
  @@map("service_templates")
}

// =============================================================================
// Registration Models
// =============================================================================

/// Registration model - represents an authorization type within a service
/// (e.g., permit, license, certificate that applicants apply for)
model Registration {
  id          String   @id @default(cuid())
  serviceId   String   @map("service_id")
  name        String   @db.VarChar(100)
  shortName   String   @db.VarChar(20) @map("short_name")
  key         String   @db.VarChar(50)
  description String?  @db.Text
  isActive    Boolean  @default(true) @map("is_active")
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  /// ADR-002: Procedure type fields with backward-compatible defaults
  /// procedureType determines the output (AUTHORIZATION=document, INQUIRY=info, etc.)
  /// triggerType determines initiation (USER_INITIATED, SCHEDULED, INSTITUTION, EVENT)
  /// outputConfig holds type-specific settings (e.g., document template ID for AUTHORIZATION)
  procedureType ProcedureType @default(AUTHORIZATION) @map("procedure_type")
  triggerType   TriggerType   @default(USER_INITIATED) @map("trigger_type")
  outputConfig  Json?         @map("output_config")

  // Relations
  service              Service               @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  documentRequirements DocumentRequirement[]
  costs                Cost[]
  roles                RoleRegistration[]

  // Compound unique: key must be unique within each service
  @@unique([serviceId, key])
  @@index([serviceId])
  @@index([isActive])
  @@index([procedureType])
  @@index([triggerType])
  @@map("registrations")
}

// =============================================================================
// Requirement & Cost Models
// =============================================================================

/// Requirement model - global document type definitions (reusable templates)
model Requirement {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(100)
  tooltip   String?  @db.Text
  template  String?  @db.VarChar(500) // Document template reference
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  documentRequirements DocumentRequirement[]

  @@index([isActive])
  @@map("requirements")
}

/// DocumentRequirement model - links global Requirements to specific Registrations
model DocumentRequirement {
  id             String   @id @default(cuid())
  registrationId String   @map("registration_id")
  requirementId  String   @map("requirement_id")
  nameOverride   String?  @db.VarChar(100) @map("name_override")
  isRequired     Boolean  @default(true) @map("is_required")
  sortOrder      Int      @default(0) @map("sort_order")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  registration Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  requirement  Requirement  @relation(fields: [requirementId], references: [id], onDelete: Cascade)

  // Each requirement can only be added once per registration
  @@unique([registrationId, requirementId])
  @@index([registrationId])
  @@index([requirementId])
  @@map("document_requirements")
}

/// Cost model - registration-specific fees with FIXED or FORMULA types
model Cost {
  id             String   @id @default(cuid())
  registrationId String   @map("registration_id")
  name           String   @db.VarChar(100)
  type           CostType
  fixedAmount    Decimal? @map("fixed_amount") @db.Decimal(10, 2)
  formula        String?  @db.Text // JSONata expression for calculated costs
  currency       String   @default("USD") @db.VarChar(3)
  sortOrder      Int      @default(0) @map("sort_order")
  isActive       Boolean  @default(true) @map("is_active")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  registration Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade)

  @@index([registrationId])
  @@index([isActive])
  @@map("costs")
}

// =============================================================================
// Form Models
// =============================================================================

/// Form model - represents a data collection form within a service
model Form {
  id        String   @id @default(cuid())
  serviceId String   @map("service_id")
  type      FormType
  name      String   @db.VarChar(255)
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  service  Service       @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  sections FormSection[]
  fields   FormField[]
  roles    Role[]

  // Each service can have multiple forms, but unique names per service
  @@unique([serviceId, name])
  @@index([serviceId])
  @@index([type])
  @@index([isActive])
  @@map("forms")
}

/// FormSection model - organizes form fields into groups with optional nesting
model FormSection {
  id              String   @id @default(cuid())
  formId          String   @map("form_id")
  parentSectionId String?  @map("parent_section_id")
  name            String   @db.VarChar(255)
  description     String?  @db.Text
  sortOrder       Int      @default(0) @map("sort_order")
  visibilityRule  Json?    @map("visibility_rule") // Conditional visibility configuration
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  form          Form          @relation(fields: [formId], references: [id], onDelete: Cascade)
  parentSection FormSection?  @relation("SectionNesting", fields: [parentSectionId], references: [id], onDelete: Cascade)
  childSections FormSection[] @relation("SectionNesting")
  fields        FormField[]

  @@index([formId])
  @@index([parentSectionId])
  @@index([isActive])
  @@map("form_sections")
}

/// FormField model - represents a single field in a form
model FormField {
  id             String   @id @default(cuid())
  formId         String   @map("form_id")
  sectionId      String?  @map("section_id")
  determinantId  String?  @map("determinant_id")
  type           String   @db.VarChar(50) // JSON Forms field type (text, number, date, select, etc.)
  label          String   @db.VarChar(255)
  name           String   @db.VarChar(100) // Field identifier (used in form data)
  required       Boolean  @default(false)
  properties     Json     @default("{}") // Type-specific properties (placeholder, min, max, options, etc.)
  visibilityRule Json?    @map("visibility_rule") // Conditional visibility configuration
  sortOrder      Int      @default(0) @map("sort_order")
  isActive       Boolean  @default(true) @map("is_active")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  form                Form         @relation(fields: [formId], references: [id], onDelete: Cascade)
  section             FormSection? @relation(fields: [sectionId], references: [id], onDelete: SetNull)
  determinant         Determinant? @relation("LinkedDeterminant", fields: [determinantId], references: [id], onDelete: SetNull)
  derivedDeterminants Determinant[] @relation("SourceField")

  // Field name must be unique within a form
  @@unique([formId, name])
  @@index([formId])
  @@index([sectionId])
  @@index([determinantId])
  @@index([isActive])
  @@map("form_fields")
}

// =============================================================================
// Determinant Models
// =============================================================================

/// Determinant model - represents a business rule variable derived from form fields
model Determinant {
  id            String          @id @default(cuid())
  serviceId     String          @map("service_id")
  name          String          @db.VarChar(100)
  type          DeterminantType
  sourceFieldId String?         @map("source_field_id")
  formula       String?         @db.Text // JSONata expression (for Epic 5)
  isActive      Boolean         @default(true) @map("is_active")
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @updatedAt @map("updated_at")

  // Relations
  service      Service     @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  sourceField  FormField?  @relation("SourceField", fields: [sourceFieldId], references: [id], onDelete: SetNull)
  linkedFields FormField[] @relation("LinkedDeterminant")

  // Determinant name must be unique within a service
  @@unique([serviceId, name])
  @@index([serviceId])
  @@index([sourceFieldId])
  @@index([isActive])
  @@map("determinants")
}

// =============================================================================
// Workflow Models
// =============================================================================

/// Role - workflow step (polymorphic via roleType)
/// Represents a processing point in the workflow - either human (USER) or automated (BOT)
model Role {
  id                   String       @id @default(cuid())
  serviceId            String       @map("service_id")
  roleType             RoleType     @map("role_type")
  name                 String       @db.VarChar(255)
  shortName            String?      @map("short_name") @db.VarChar(50)
  description          String?      @db.Text
  isStartRole          Boolean      @default(false) @map("is_start_role")
  sortOrder            Int          @default(100) @map("sort_order")
  isActive             Boolean      @default(true) @map("is_active")
  conditions           Json?        // Determinant-based activation conditions
  createdAt            DateTime     @default(now()) @map("created_at")
  updatedAt            DateTime     @updatedAt @map("updated_at")

  /// ADR-003: Actor type fields with backward-compatible defaults
  /// actorType identifies who performs actions (APPLICANT, OPERATOR, SYSTEM)
  /// isEntryPoint marks roles where applicants first interact (typically APPLICANT actors only)
  actorType            ActorType    @default(OPERATOR) @map("actor_type")
  isEntryPoint         Boolean      @default(false) @map("is_entry_point")

  // UserRole-specific fields (nullable, applies only when roleType = USER)
  formId               String?      @map("form_id")

  // BotRole-specific fields (nullable, applies only when roleType = BOT)
  retryEnabled         Boolean?     @default(false) @map("retry_enabled")
  retryIntervalMinutes Int?         @map("retry_interval_minutes")
  timeoutMinutes       Int?         @map("timeout_minutes")

  // Relations
  service              Service            @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  form                 Form?              @relation(fields: [formId], references: [id], onDelete: SetNull)
  statuses             RoleStatus[]
  incomingTransitions  WorkflowTransition[] @relation("TransitionTarget")
  registrations        RoleRegistration[]
  institutions         RoleInstitution[]

  @@unique([serviceId, name])
  @@index([serviceId])
  @@index([roleType])
  @@index([sortOrder])
  @@index([isActive])
  @@index([actorType])
  @@map("roles")
}

/// RoleRegistration - N:N binding between Role and Registration
/// Enables multi-registration workflows where roles process specific registration types
model RoleRegistration {
  id                String   @id @default(cuid())
  roleId            String   @map("role_id")
  registrationId    String   @map("registration_id")
  finalResultIssued Boolean  @default(false) @map("final_result_issued")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  role         Role         @relation(fields: [roleId], references: [id], onDelete: Cascade)
  registration Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade)

  @@unique([roleId, registrationId])
  @@index([roleId])
  @@index([registrationId])
  @@map("role_registrations")
}

/// Institution - organizational entity that can be assigned to workflow roles
/// Represents government agencies, ministries, or other organizations
model Institution {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(255)
  code      String   @unique @db.VarChar(50)
  country   String?  @db.VarChar(10)
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  roles RoleInstitution[]

  @@index([country])
  @@index([isActive])
  @@map("institutions")
}

/// RoleInstitution - N:N binding between Role and Institution
/// Enables multi-institution workflows where operators from assigned institutions can process
model RoleInstitution {
  id            String   @id @default(cuid())
  roleId        String   @map("role_id")
  institutionId String   @map("institution_id")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  role        Role        @relation(fields: [roleId], references: [id], onDelete: Cascade)
  institution Institution @relation(fields: [institutionId], references: [id], onDelete: Cascade)

  @@unique([roleId, institutionId])
  @@index([roleId])
  @@index([institutionId])
  @@map("role_institutions")
}

/// RoleStatus - workflow outcome options (4-Status Model)
/// Each role has 1-4 status options representing possible decisions
model RoleStatus {
  id          String             @id @default(cuid())
  roleId      String             @map("role_id")
  code        RoleStatusCode
  name        String             @db.VarChar(100)
  isDefault   Boolean            @default(false) @map("is_default")
  sortOrder   Int                @default(0) @map("sort_order")
  conditions  Json?              // When to show this status option
  createdAt   DateTime           @default(now()) @map("created_at")
  updatedAt   DateTime           @updatedAt @map("updated_at")

  // Relations
  role        Role               @relation(fields: [roleId], references: [id], onDelete: Cascade)
  transitions WorkflowTransition[] @relation("FromStatus")

  @@index([roleId])
  @@index([code])
  @@map("role_statuses")
}

/// WorkflowTransition - routing from status outcome to next role
/// Defines where the workflow goes after a role produces a status
model WorkflowTransition {
  id           String     @id @default(cuid())
  fromStatusId String     @map("from_status_id")
  toRoleId     String     @map("to_role_id")
  sortOrder    Int        @default(0) @map("sort_order")
  conditions   Json?      // Conditional routing
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  // Relations
  fromStatus   RoleStatus @relation("FromStatus", fields: [fromStatusId], references: [id], onDelete: Cascade)
  toRole       Role       @relation("TransitionTarget", fields: [toRoleId], references: [id], onDelete: Cascade)

  @@unique([fromStatusId, toRoleId])
  @@index([fromStatusId])
  @@index([toRoleId])
  @@map("workflow_transitions")
}
